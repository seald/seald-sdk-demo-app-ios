//
//  SEALDSDKAppDelegate.m
//  SealdSDK
//
//  Created by clement on 02/13/2023.
//  Copyright (c) 2023 Seald SAS. All rights reserved.
//

#import "SEALDSDKAppDelegate.h"
#import <SealdSdk/SealdSdk.h>
#import <JWT/JWT.h>
#import "JWTBuilder.h"

@implementation SEALDSDKAppDelegate

- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions
{
    // Seald account infos:
    // First step with Seald: https://docs.seald.io/en/sdk/guides/1-quick-start.html
    // Create a team here: https://www.seald.io/create-sdk
    NSString *apiURL = @"https://api-dev.soyouz.seald.io/";
    NSString *appId = @"00000000-0000-1000-a000-7ea300000018";
    NSString *JWTSharedSecretId = @"00000000-0000-1000-a000-7ea300000019";
    NSString *JWTSharedSecret = @"o75u89og9rxc9me54qxaxvdutr2t4t25ozj4m64utwemm0osld0zdb02j7gv8t7x";
    
    // The Seald SDK uses a local database that will persist on disk.
    // When instantiating a SealdSDK, it is highly recommended to set a symmetric key to encrypt this database.
    // This demo will use a fixed key. It should be generated at signup, and retrieved from your backend at login.
    NSString *databaseEncryptionKeyB64 = @"V4olGDOE5bAWNa9HDCvOACvZ59hUSUdKmpuZNyl1eJQnWKs5/l+PGnKUv4mKjivL3BtU014uRAIF2sOl83o6vQ";
    
    // Find database Path
    NSArray *paths = NSSearchPathForDirectoriesInDomains
                (NSDocumentDirectory, NSUserDomainMask, YES);
    NSString *documentsDirectory = [paths objectAtIndex:0];
    NSString *sealdDir = [NSString stringWithFormat:@"%@/seald", documentsDirectory];
    
    // Delete local database from previous run
    NSLog(@"Deleting local database from previous run...");
    NSFileManager *fileManager = [NSFileManager defaultManager];
    NSError *error = nil;
    if ([fileManager removeItemAtPath:sealdDir error:&error]) {
       NSLog(@"Seald Database removed successfully");
    } else {
        NSLog(@"Error removing Seald database %@", error.userInfo);
    }
    
    // Seald uses JWT to manage licenses and identity.
    // JWTs should be generated by your backend, and sent to the user at signup.
    // The JWT secretId and secret can be generated from your administration dashboard. They should NEVER be on client side.
    // However, as this is a demo without a backend, we will use them on the frontend.
    // JWT documentation: https://docs.seald.io/en/sdk/guides/jwt.html
    // identity documentation: https://docs.seald.io/en/sdk/guides/4-identities.html
    DemoAppJWTBuilder *jwtbuilder = [[DemoAppJWTBuilder alloc] initWithJWTSharedSecretId:JWTSharedSecretId JWTSharedSecret:JWTSharedSecret];

    // let's instantiate 3 SealdSDK. They will correspond to 3 users that will exchange messages.
    SealdSdk *sdk1 = [[SealdSdk alloc] initWithApiUrl:apiURL appId:appId dbPath:[NSString stringWithFormat:@"%@/inst1", sealdDir] dbb64SymKey:databaseEncryptionKeyB64 instanceName:@"User1" logLevel:0 logNoColor:true encryptionSessionCacheTTL:0 keySize:4096 error:&error];
    NSParameterAssert(error == nil);
    SealdSdk *sdk2 = [[SealdSdk alloc] initWithApiUrl:apiURL appId:appId dbPath:[NSString stringWithFormat:@"%@/inst2", sealdDir] dbb64SymKey:databaseEncryptionKeyB64 instanceName:@"User2" logLevel:0 logNoColor:true encryptionSessionCacheTTL:0 keySize:4096 error:&error];
    NSParameterAssert(error == nil);
    SealdSdk *sdk3 = [[SealdSdk alloc] initWithApiUrl:apiURL appId:appId dbPath:[NSString stringWithFormat:@"%@/inst3", sealdDir] dbb64SymKey:databaseEncryptionKeyB64 instanceName:@"User3" logLevel:0 logNoColor:true encryptionSessionCacheTTL:0 keySize:4096 error:&error];
    NSParameterAssert(error == nil);
    
    SealdAccountInfo *retrieveNoAccount = [sdk1 getCurrentAccountInfo];
    NSParameterAssert(retrieveNoAccount != nil);
    
    // Create the 3 accounts. Again, the signupJWT should be generated by your backend
    SealdAccountInfo* user1AccountInfo = [sdk1 createAccountWithSignupJwt:[jwtbuilder signupJWT] deviceName:@"deviceNameUser1" displayName:@"User1" expireAfter:0 error:&error];
    NSParameterAssert(error == nil);
    SealdAccountInfo* user2AccountInfo = [sdk2 createAccountWithSignupJwt:[jwtbuilder signupJWT] deviceName:@"deviceNameUser2" displayName:@"User2" expireAfter:0 error:&error];
    NSParameterAssert(error == nil);
    SealdAccountInfo* user3AccountInfo = [sdk3 createAccountWithSignupJwt:[jwtbuilder signupJWT] deviceName:@"deviceNameUser3" displayName:@"User3" expireAfter:0 error:&error];
    NSParameterAssert(error == nil);
    
    SealdAccountInfo *retrieveAccountInfo = [sdk1 getCurrentAccountInfo];
    NSParameterAssert([retrieveAccountInfo.userId isEqualToString:user1AccountInfo.userId]);
    NSParameterAssert([retrieveAccountInfo.deviceId isEqualToString:user1AccountInfo.deviceId]);
    
    NSArray<NSString*>* members = [NSArray arrayWithObject:user1AccountInfo.userId];
    NSArray<NSString*>* admins = [NSArray arrayWithObject:user1AccountInfo.userId];
    NSString* groupId = [sdk1 createGroup:@"group-1" members:members admins:admins error:&error];
    NSParameterAssert(error == nil);
    
    // Manage group members and admins
    [sdk1 addGroupMembersWithGroupId:groupId membersToAdd:[NSArray arrayWithObject:user2AccountInfo.userId] adminsToSet:[NSArray new] error:&error];
    NSParameterAssert(error == nil);
    [sdk1 addGroupMembersWithGroupId:groupId membersToAdd:[NSArray arrayWithObject:user3AccountInfo.userId] adminsToSet:[NSArray arrayWithObject:user3AccountInfo.userId] error:&error];
    NSParameterAssert(error == nil);
    [sdk3 removeGroupMembersWithGroupId:groupId membersToRemove:[NSArray arrayWithObject:user2AccountInfo.userId] error:&error];
    NSParameterAssert(error == nil);
    [sdk3 setGroupAdminsWithGroupId:groupId addToAdmins:[NSArray new] removeFromAdmins:[NSArray arrayWithObject:user1AccountInfo.userId] error:&error];
    NSParameterAssert(error == nil);
    
    // Create encryption session: https://docs.seald.io/sdk/guides/6-encryption-sessions.html
    NSArray<NSString*>* recipients = [NSArray arrayWithObjects:user1AccountInfo.userId, user2AccountInfo.userId, groupId, nil];
    SealdEncryptionSession *es1SDK1 = [sdk1 createEncryptionSessionWithRecipients:recipients useCache:@YES error:&error];
    NSParameterAssert(error == nil);
    
    // The io.seald.seald_sdk.EncryptionSession object can encrypt and decrypt for user1
    NSString *initialString = @"a message that needs to be encrypted!";
    NSString *encryptedMessage = [es1SDK1 encryptMessage:initialString error:&error];
    NSParameterAssert(error == nil);
    NSString *decryptedMessage = [es1SDK1 decryptMessage:encryptedMessage error:&error];
    NSParameterAssert(error == nil);
    NSParameterAssert([decryptedMessage isEqualToString:initialString]);
    
    // user1 can retrieve the EncryptionSession from the encrypted message
    SealdEncryptionSession *es1SDK1RetrieveFromMess = [sdk1 retrieveEncryptionSessionFromMessage:encryptedMessage useCache:@YES error:&error];
    NSParameterAssert(error == nil);
    NSString *decryptedMessageFromMess = [es1SDK1RetrieveFromMess decryptMessage:encryptedMessage error:&error];
    NSParameterAssert(error == nil);
    NSParameterAssert([decryptedMessageFromMess isEqualToString:initialString]);

    // user2 and user3 can retrieve the encryptionSession (from the encrypted message or the session ID).
    SealdEncryptionSession *es1SDK2 = [sdk2 retrieveEncryptionSessionWithSessionId:es1SDK1.sessionId useCache:@YES error:&error];
    NSParameterAssert(error == nil);
    NSString *decryptedMessageSDK2 = [es1SDK2 decryptMessage:encryptedMessage error:&error];
    NSParameterAssert(error == nil);
    NSParameterAssert([decryptedMessageSDK2 isEqualToString:initialString]);
    
    SealdEncryptionSession *es1SDK3FromGroup = [sdk3 retrieveEncryptionSessionFromMessage:encryptedMessage useCache:@YES error:&error];
    NSParameterAssert(error == nil);
    NSString *decryptedMessageSDK3 = [es1SDK3FromGroup decryptMessage:encryptedMessage error:&error];
    NSParameterAssert(error == nil);
    NSParameterAssert([decryptedMessageSDK3 isEqualToString:initialString]);
    
    // user3 removes all members of "group-1". A group without member is deleted.
    [sdk3 removeGroupMembersWithGroupId:groupId membersToRemove:[NSArray arrayWithObjects:user1AccountInfo.userId, user3AccountInfo.userId, nil] error:&error];
    NSParameterAssert(error == nil);
    
    // user3 could retrieve the previous encryption session only because "group-1" was set as recipient.
    // As the group was deleted, it can no longer access it.
    // user3 still has the encryption session in its cache, but we can disable it.
    NSParameterAssert(error == nil);
    [sdk3 retrieveEncryptionSessionFromMessage:encryptedMessage useCache:@YES error:&error];
    NSParameterAssert(error != nil);
    NSRange range = [error.localizedDescription rangeOfString:@"status: 404"];
    NSParameterAssert(range.location != NSNotFound);
    error = nil;
    
    // user2 adds user3 as recipient of the encryption session.
    [es1SDK2 addRecipients:[NSArray arrayWithObject:user3AccountInfo.userId] error:&error];
    error = nil;

    // user3 can now retrieve it.
    SealdEncryptionSession *es1SDK3 = [sdk3 retrieveEncryptionSessionWithSessionId:es1SDK1.sessionId useCache:@NO error:&error];
    NSString *decryptedMessageAfterAdd = [es1SDK3 decryptMessage:encryptedMessage error:&error];
    NSParameterAssert(error == nil);
    NSParameterAssert([initialString isEqualToString:decryptedMessageAfterAdd]);

    // user2 revokes user3 from the encryption session.
    [es1SDK2 revokeRecipients:[NSArray arrayWithObject:user3AccountInfo.userId] error:&error];

    // user3 cannot retrieve the session anymore
    NSParameterAssert(error == nil);
    [sdk3 retrieveEncryptionSessionWithSessionId:es1SDK1.sessionId useCache:@NO error:&error];
    NSParameterAssert(error != nil);
    range = [error.localizedDescription rangeOfString:@"status: 404"];
    NSParameterAssert(range.location != NSNotFound);
    error = nil;
    
    // user1 revokes all other recipients from the session
    [es1SDK1 revokeOthers:&error];
    NSParameterAssert(error == nil);
    
    // user2 cannot retrieve the session anymore
    NSParameterAssert(error == nil);
    [sdk2 retrieveEncryptionSessionFromMessage:encryptedMessage useCache:@NO error:&error];
    NSParameterAssert(error != nil);
    range = [error.localizedDescription rangeOfString:@"status: 404"];
    NSParameterAssert(range.location != NSNotFound);
    error = nil;
    
    // user1 revokes all. It can no longer retrieve it.
    [es1SDK1 revokeAll:&error];
    NSParameterAssert(error == nil);
    
    // Create additional data for user1
    SealdEncryptionSession *es2SDK1 = [sdk1 createEncryptionSessionWithRecipients:[NSArray arrayWithObject:user1AccountInfo.userId] useCache:@YES error:&error];
    NSParameterAssert(error == nil);
    NSString *anotherMessage = @"Nobody should read that!";
    NSString *secondEncryptedMessage = [es2SDK1 encryptMessage:anotherMessage error:&error];
    NSParameterAssert(error == nil);
    
    // user1 can renew its key, and still decrypt old messages
    [sdk1 renewKeysWithExpireAfter:5 * 365 * 24 * 60 * 60 error:&error];
    NSParameterAssert(error == nil);
    SealdEncryptionSession *es2SDK1AfterRenew = [sdk1 retrieveEncryptionSessionFromMessage:secondEncryptedMessage useCache:@YES error:&error];
    NSParameterAssert(error == nil);
    NSString *decryptedMessageAfterRenew = [es2SDK1AfterRenew decryptMessage:secondEncryptedMessage error:&error];
    NSParameterAssert(error == nil);
    NSParameterAssert([anotherMessage isEqualToString:decryptedMessageAfterRenew]);
    
    // CONNECTORS https://docs.seald.io/en/sdk/guides/jwt.html#adding-a-userid

    // we can add a custom userId using a JWT
    NSString *customConnectorJWTValue = @"user1-custom-id";
    NSString *addConnectorJWT = [jwtbuilder connectorJWTWithCustomUserId:customConnectorJWTValue appId:appId];
    
    [sdk1 pushJWT:addConnectorJWT error:&error];
    NSParameterAssert(error == nil);
    
    NSArray<SealdConnector *> *connectors = [sdk1 listConnectorsWithError:&error];
    NSParameterAssert(error == nil);
    NSString *expectedConnectorValue = [NSString stringWithFormat:@"%@@%@", customConnectorJWTValue, appId];
    NSParameterAssert([connectors count] == 1);
    NSParameterAssert([@"AP" isEqualToString:connectors[0].type]);
    NSParameterAssert([@"VO" isEqualToString:connectors[0].state]);
    NSParameterAssert([user1AccountInfo.userId isEqualToString:connectors[0].sealdId]);
    NSParameterAssert([expectedConnectorValue isEqualToString:connectors[0].value]);
    
    // Retrieve connector by its id
    SealdConnector *retrieveConnector = [sdk1 retrieveConnector:connectors[0].connectorId error:&error];
    NSParameterAssert(error == nil);
    NSParameterAssert([@"AP" isEqualToString:retrieveConnector.type]);
    NSParameterAssert([@"VO" isEqualToString:retrieveConnector.state]);
    NSParameterAssert([user1AccountInfo.userId isEqualToString:retrieveConnector.sealdId]);
    NSParameterAssert([expectedConnectorValue isEqualToString:retrieveConnector.value]);
    
    // Retrieve connectors from a user id.
    NSArray<SealdConnector *> *connectorsFromSealdId = [sdk1 getConnectorsFromSealdId:user1AccountInfo.userId error:&error];
    NSParameterAssert(error == nil);
    NSParameterAssert([connectorsFromSealdId count] == 1);
    NSParameterAssert([@"AP" isEqualToString:connectorsFromSealdId[0].type]);
    NSParameterAssert([@"VO" isEqualToString:connectorsFromSealdId[0].state]);
    NSParameterAssert([user1AccountInfo.userId isEqualToString:connectorsFromSealdId[0].sealdId]);
    NSParameterAssert([expectedConnectorValue isEqualToString:connectorsFromSealdId[0].value]);
    
    // Get sealdId of a user from a connector
    SealdConnectorTypeValue *connectorToSearch = [[SealdConnectorTypeValue alloc] initWithType:@"AP" value:expectedConnectorValue];
    NSArray *sealdIds = [sdk1 getSealdIdsFromConnectors:[NSArray arrayWithObject:connectorToSearch] error:&error];
    NSParameterAssert(error == nil);
    NSParameterAssert([sealdIds count] == 1);
    NSParameterAssert([user1AccountInfo.userId isEqualToString:sealdIds[0]]);
    
    // user1 can remove a connector
    [sdk1 removeConnector:connectors[0].connectorId error:&error];
    NSParameterAssert(error == nil);
    
    // verify that only no connector left
    NSArray<SealdConnector *> *connectorListAfterRevoke = [sdk1 listConnectorsWithError:&error];
    NSParameterAssert(error == nil);
    NSParameterAssert([connectorListAfterRevoke count] == 0);
    
    // user1 can export its identity
    NSData *exportedIdentity = [sdk1 exportIdentityWithError:&error];
    NSParameterAssert(error == nil);
    
    // We can instantiate a new SealdSDK, import the exported identity
    SealdSdk *sdk1Exported = [[SealdSdk alloc] initWithApiUrl:apiURL appId:appId dbPath:[NSString stringWithFormat:@"%@/inst1Exported", sealdDir] dbb64SymKey:databaseEncryptionKeyB64 instanceName:@"User1Exported" logLevel:0 logNoColor:true encryptionSessionCacheTTL:0 keySize:4096 error:&error];
    NSParameterAssert(error == nil);
    [sdk1Exported importIdentity:exportedIdentity error:&error];
    NSParameterAssert(error == nil);
    
    /**
    // SDK with imported identity can decrypt
    SealdEncryptionSession *es2SDK1Exported = [sdk1Exported retrieveEncryptionSessionFromMessage:secondEncryptedMessage useCache:@YES error:&error];
    NSParameterAssert(error == nil);
    NSString *clearMessageExportedIdentity = [es2SDK1Exported decryptMessage:secondEncryptedMessage error:&error];
    NSParameterAssert(error == nil);
    NSParameterAssert([anotherMessage isEqualToString:clearMessageExportedIdentity]);

    // user1 can create sub identity
    SealdCreateSubIdentityResponse *subIdentity = [sdk1 createSubIdentityWithDeviceName:@"Sub-device" expireAfter:365 * 24 * 60 * 60 error:&error];
    NSParameterAssert(error == nil);
    NSParameterAssert(subIdentity.deviceId != nil);
    
    // first device needs to reencrypt for the new device
    SealdMassReencryptOptions *massReencryptOpts = [[SealdMassReencryptOptions alloc] init];
    [sdk1 massReencryptWithDeviceId:subIdentity.deviceId options:massReencryptOpts error:&error];
    NSParameterAssert(error == nil);
    
    // We can instantiate a new SealdSDK, import the sub-device identity
    SealdSdk *sdk1SubDevice = [[SealdSdk alloc] initWithApiUrl:apiURL appId:appId dbPath:[NSString stringWithFormat:@"%@/inst1Exported", sealdDir] dbb64SymKey:databaseEncryptionKeyB64 instanceName:@"User1SubDevice" logLevel:0 logNoColor:true encryptionSessionCacheTTL:0 keySize:4096 error:&error];
    NSParameterAssert(error == nil);
    [sdk1SubDevice importIdentity:subIdentity.backupKey error:&error];
    NSParameterAssert(error == nil);
    
    // sub device can decrypt
    SealdEncryptionSession *es2SDK1SubDevice = [sdk1SubDevice retrieveEncryptionSessionFromMessage:secondEncryptedMessage useCache:@YES error:&error];
    NSParameterAssert(error == nil);
    NSString *clearMessageSubdIdentity = [es2SDK1SubDevice decryptMessage:secondEncryptedMessage error:&error];
    NSParameterAssert(error == nil);
    NSParameterAssert([anotherMessage isEqualToString:clearMessageSubdIdentity]);
     */
    
    // close SDKs
    [sdk1 heartbeatWithError:&error];
    NSParameterAssert(error == nil);
    
    // close SDKs
    [sdk1 closeWithError:&error];
    NSParameterAssert(error == nil);
    [sdk2 closeWithError:&error];
    NSParameterAssert(error == nil);
    [sdk3 closeWithError:&error];
    NSParameterAssert(error == nil);
    return YES;
}

- (void)applicationWillResignActive:(UIApplication *)application
{
    // Sent when the application is about to move from active to inactive state. This can occur for certain types of temporary interruptions (such as an incoming phone call or SMS message) or when the user quits the application and it begins the transition to the background state.
    // Use this method to pause ongoing tasks, disable timers, and throttle down OpenGL ES frame rates. Games should use this method to pause the game.
}

- (void)applicationDidEnterBackground:(UIApplication *)application
{
    // Use this method to release shared resources, save user data, invalidate timers, and store enough application state information to restore your application to its current state in case it is terminated later.
    // If your application supports background execution, this method is called instead of applicationWillTerminate: when the user quits.
}

- (void)applicationWillEnterForeground:(UIApplication *)application
{
    // Called as part of the transition from the background to the inactive state; here you can undo many of the changes made on entering the background.
}

- (void)applicationDidBecomeActive:(UIApplication *)application
{
    // Restart any tasks that were paused (or not yet started) while the application was inactive. If the application was previously in the background, optionally refresh the user interface.
}

- (void)applicationWillTerminate:(UIApplication *)application
{
    // Called when the application is about to terminate. Save data if appropriate. See also applicationDidEnterBackground:.
}

@end
